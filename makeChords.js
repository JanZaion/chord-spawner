'use strict';
const scribble = require('scribbletune');
const { Note, Interval, interval, Progression, Mode } = require('@tonaljs/tonal');

function diceRange(max, min) {
  //Dice roll, returns any number in the min-max range. Careful: The max number is excluded, so a roll for 2-8 would look like this: diceRange(9, 2)
  return Math.floor(Math.random() * (max - min) + min);
}

function diceMultiRollSortedASC(max, min, rolls) {
  //Multiple dice rolls, returns an array of ascending different numbers that is as long as the 'rolls' input. Max is excluded just like with diceRange.
  let arr = [];
  while (arr.length < rolls) {
    let r = Math.floor(Math.random() * (max - min) + min);
    if (arr.indexOf(r) === -1) arr.push(r);
  }
  return arr.sort(function (a, b) {
    return a - b;
  });
}

Array.prototype.insert = function (index, item) {
  //Inserts item to an array and changes the length (index, item)
  this.splice(index, 0, item);
};

function indexOfSmallest(a) {
  //finds an index of the smallest element in an array of numbers
  return a.indexOf(Math.min.apply(Math, a));
}

function indexOfHighest(a) {
  //finds an index of the highest element in an array of numbers
  return a.indexOf(Math.max.apply(Math, a));
}

//It turns out that Scribbletune accepts notes as strings, but if they are not arrays, it exports them kinda wonky. This function loops through a scribbleClip and converts all string notes to array notes
function notesToArray(scribbleClip) {
  for (let i = 0; i < scribbleClip.length; i++) {
    if (Array.isArray(scribbleClip[i].note) == false && scribbleClip[i].note != null) {
      var noteInArray = [];
      noteInArray.push(scribbleClip[i].note);
      var newPart = { note: noteInArray, length: scribbleClip[i].length, level: scribbleClip[i].level };
      scribbleClip.splice(i, 1);
      scribbleClip.insert(i, newPart);
    }
  }

  return scribbleClip;
}

//The clip that was generated by the previous algo is usable, but further retrieval of data might pose a problem, so here we consolidate all the null note scribble objects so that there are never 2 in a row, just 1 with the appropriate length.
function nullCleanup(scribbleClip) {
  for (var q = 0; q < scribbleClip.length; q++) {
    if (q != scribbleClip.length - 1 && scribbleClip[q].note == null && scribbleClip[q + 1].note == null) {
      var newNullLength = scribbleClip[q].length + scribbleClip[q + 1].length;
      var newPart = { note: null, length: newNullLength, level: scribbleClip[q].level };
      scribbleClip.splice(q, 2);
      scribbleClip.insert(q, newPart);
      var q = q - 1;
    }
  }
  return scribbleClip;
}

//We count the number of nulls and root notes and then make couple of checks of whether we can continue based on how many notes are there to change to return unedited clip rather than error. This Function works as an auxiliary function for functions that have number of notes and first note specified to modify scribbletune clip
function contingency(scribbleClip, numOfNotes, firstNote, RN, transposeRN) {
  var RNamount = 0;
  var Nullamount = 0;

  for (let i = 0; i < scribbleClip.length; i++) {
    if (scribbleClip[i].note == null) {
      Nullamount++;
    } else if (scribbleClip[i].note.join('') == RN) {
      RNamount++;
    }
  }

  var nonRNamount = scribbleClip.length - RNamount - Nullamount;

  if (transposeRN && nonRNamount + RNamount < 1) {
    return true;
  } else if (transposeRN == false && nonRNamount < 1) {
    return true;
  } else if (numOfNotes < 1) {
    return true;
  } else if (firstNote > scribbleClip.length) {
    return true;
  } else {
    return false;
  }
}

//Accepts string and converts it to boolean values, provided the string is yes, no, on or off
function humanToBool(str) {
  switch (str) {
    case 'yes':
      str = true;
      break;

    case 'no':
      str = false;
      break;

    case 'on':
      str = true;
      break;

    case 'off':
      str = false;
      break;
    case 'sevenths':
      str = true;
      break;

    case 'triads':
      str = false;
      break;
    case 0: //inverted logic for indexes
      str = true;
      break;

    case 1:
      str = false;
      break;
  }
  return str;
}

/*
Converts a chord to an arabic numeral (substituting the function of a roman numeral in a standard chord notation) based on the inputed root note of a chord and a desired key.
-RN accepts a string that denotes the root note of a key, ie 'C' of C major
-mode accepts either of the 4 possible strings: "major", "minor", "ionian", "dorian", "phrygian", "lydian", "mixolydian", "aeolian", "locrian"
-chord accepts a string of a chord
*/
function absoluteToRelativeChord(RN, mode, chord) {
  let notes = Mode.notes(mode, RN);

  if (chord.indexOf('#') == 1 || chord.indexOf('b') == 1) {
    var chordRoot = chord.slice(0, 2);
  } else {
    var chordRoot = chord.slice(0, 1);
  }

  return notes.indexOf(chordRoot) + 1;
}

/*
Translates an array of chords from roman notation to absolute chord notation.
-RN accepts a string that denotes the root note of a key, ie 'C' of C major
-chords accepts array of strings
*/
function romans(RN, chords) {
  for (let i = 0; i < chords.length; i++) {
    let chord = chords[i];

    if (chord.match(/[ iIVv ]/) !== null && chord.indexOf('dim') === -1) {
      if (chord.toLowerCase() === chord) {
        switch (chord.indexOf(7) === -1) {
          case true:
            chord = chord + 'm';
            break;

          case false:
            chord = chord.slice(0, -1);
            chord = chord + 'm' + '7';
            break;
        }
      } else if (
        chord.indexOf('maj') === -1 &&
        chord.indexOf('Maj') === -1 &&
        chord.indexOf('min') === -1 &&
        chord.indexOf('Min') === -1 &&
        chord.indexOf('m') === -1
      ) {
        switch (chord.indexOf(7) === -1) {
          case true:
            chord = chord + 'M';
            break;

          case false:
            chord = chord.slice(0, -1);
            chord = chord + 'M' + '7';
            break;
        }
      }
      let chordarr = [];
      chordarr.push(chord);
      chordarr = Progression.fromRomanNumerals(RN, chordarr);
      chords[i] = chordarr[0];
    }
  }
  return chords;
}

/*
Transposes a note in a chord.
-scribbleClip accepts a Scribbletune clip
-firstChord accepts number and it denotes at which chord in the scribbleclip array to start transposing
-numOfChords accepts number and it denotes the amount of chords that will have a transposed note
-numNote accepts array and denotes which notes from the chord to transpose, ie 1 (in ie [1, 2...]) in [ 'F4', 'A4', 'C4', 'E5' ] will transpose 'F4'. Alternatively it accepts "all"
-interval accepts string and it denots the interval to transpose. It also accepts number. If input is a number, then it transposes the note by a given number of semitones or more probably fifths, im not sure. Mind up ('m2') vs down ('-2m')

In the future:
-it might also accept name of to note and as parameter to denote which note to transpose, instead of just numNote
-when Scribbletune creates a chord, it orders the notes in array from lowest to highest. Pretty logical. When a scribbleclip gets altered by this function, the original order of the notes stays the same. Meaning, that if we transpose 'F4' in [ 'F4', 'A4', 'C5' ] by '8P', the new chord will be [ 'F5', 'A4', 'C5' ] instead of [ 'A4', 'C5', 'F5' ]. It might be useful to write a function that fixes this.
*/
function transposeNotesInChord(scribbleClip, firstChord, numOfChords, numNote, interval) {
  if (isNaN(interval) == false) interval = Interval.fromSemitones(interval);
  if (contingency(scribbleClip, numOfChords, firstChord, false, false)) return nullCleanup(scribbleClip);
  if (firstChord < 1) return nullCleanup(scribbleClip);
  redeclareScribbleClip(scribbleClip);
  if (numNote === 'all') numNote = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]; //lame af, I know. If we want to transpose all notes in a chord, then we just make sure there are more chord to transpose than a chord can have

  for (let i = 0; i < firstChord - 1; i++) {
    if (scribbleClip[i].note == null) firstChord++;
  }

  if (scribbleClip.length - firstChord < numOfChords) {
    var lastChord = scribbleClip.length;
  } else {
    var lastChord = firstChord - 1 + numOfChords;
  }

  for (let i = firstChord - 1; i < lastChord; i++) {
    if (scribbleClip[i].note != null) {
      for (let n = 0; n < numNote.length; n++) {
        if (numNote[n] < scribbleClip[i].note.length + 1) {
          var newNote = Note.simplify(Note.transpose(scribbleClip[i].note[numNote[n] - 1], interval));
          var currentChord = scribbleClip[i].note;

          for (let j = 0; j < currentChord.length; j++) {
            if (j + 1 == numNote[n]) currentChord[j] = newNote;
          }

          var newPart = { note: currentChord, length: scribbleClip[i].length, level: scribbleClip[i].level };
          scribbleClip.splice(i, 1);
          scribbleClip.insert(i, newPart);
        }
      }
    } else {
      lastChord++;
      if (lastChord > scribbleClip.length) var lastChord = scribbleClip.length;
    }
  }
  nullCleanup(scribbleClip);
  notesToArray(scribbleClip);
  return scribbleClip;
}

/*
Augments a chord with an inputed note
-scribbleClip accepts a Scribbletune clip
-chord accepts number and it denotes which chord in the scribbleclip array to augment
-numNote accepts number and it denotes behind which note in the chord array will the augmentingNote be inserted
-augmentingNote accepts string and it denotes which note to insert
*/
function augmentChord(scribbleClip, chord, numNote, augmentingNote) {
  if (chord < 1 || chord > scribbleClip.length) return nullCleanup(scribbleClip);

  for (let i = 0; i < chord; i++) if (scribbleClip[i].note === null) chord++;

  if (chord > scribbleClip.length) return nullCleanup(scribbleClip);
  redeclareScribbleClip(scribbleClip);

  var chord = chord - 1;
  if (scribbleClip[chord].note.length < numNote) numNote = scribbleClip[chord].note.length + 1;

  var currentChord = scribbleClip[chord].note;
  if (currentChord.indexOf(augmentingNote) === -1) currentChord.insert(numNote - 1, augmentingNote);

  var newPart = { note: currentChord, length: scribbleClip[chord].length, level: scribbleClip[chord].level };
  scribbleClip.splice(chord, 1);
  scribbleClip.insert(chord, newPart);

  nullCleanup(scribbleClip);
  notesToArray(scribbleClip);
  return scribbleClip;
}

/*
Augments all chords in a Scribbleclip with a root note that is at the 0th octave. 
-scribbleClip accepts a Scribbletune clip
-rootNotes accepts array of note strings
*/
function augmentChordsWithBassNote2(scribbleClip, rootNotes, CX) {
  let chordCount = 0;

  for (let i = 0; i < scribbleClip.length; i++) {
    if (scribbleClip[i].note !== null) {
      chordCount++;

      var bassNote = rootNotes[i] + CX;
      //var bassNote = rootNote.replace(/[1-9]/g, '1') //We transpose the root note to the 1 octave, not 0 octave, because Scribbletune produces notes an octave lower.
      augmentChord(scribbleClip, chordCount, 1, bassNote);
    }
  }

  return scribbleClip;
}

/*
Defines at which octave should the scribbleclip be created by scribblemax. Accepts Scribbletune clip and a number denoting the desired octave.
*/
function chordsToOctave(scribbleClip, octave) {
  //var octave = octave +1 //because scribblemax exports them octave lower, than scribbleclip sais.
  const defOctave = 3; //default octave, where Scribbletune exports chords
  const transp = octave - defOctave;

  switch (Math.sign(transp)) {
    case 1:
      for (let i = 0; i < transp; i++) var scribbleClip = transposeNotesInChord(scribbleClip, 1, Infinity, 'all', '8P');
      break;
    case -1:
      for (let i = 0; i < transp * -1; i++) transposeNotesInChord(scribbleClip, 1, Infinity, 'all', '-8P');
      break;
    case 0:
      break;
  }

  return scribbleClip;
}

/*
The chordMap needs to be translated from the recieved version that the chordMap matrix understands to the version that the makeChords fn understands.
*/
function translateChordMap(chordMapMatrixified) {
  const chordMap = [[], [], [], [], [], [], [], []];

  for (let i = 0; i < chordMapMatrixified.length; i++) {
    if ((i + 1) % 3 === 0 && chordMapMatrixified[i] === 1) {
      //we divide by 3 because the matrix data are always 3 digits: rolumn, row, value

      chordMap[chordMapMatrixified[i - 1]].push(chordMapMatrixified[i - 2] + 1);
    }
  }

  chordMap.forEach((element) => {
    if (element.length === 0) element.push(1);
  }); //We cannot construct chord progression if 0 chords are to follow any chord, but user might leave a row totally empty, hence if empty row, we push the 1st chord

  return chordMap;
}

const chopSplitHalve = ({ splitChop, splitter }, scribbleClip) => {
  if (splitter === 0) return scribbleClip;

  const chopLength = [0, 1, 2, 4, 8, 16, 32, 64][splitter] * 16;
  const newClip = [];

  for (const step of scribbleClip) {
    const stepLength = step.length;
    const chops = Math.trunc(stepLength) / chopLength;
    const newPart = { ...step, length: chopLength };

    for (let step2 = 0; step2 < chops; step2++) {
      //split
      if (splitChop === 0) {
        newClip.push(newPart);
      }

      //chop
      if (splitChop === 1) {
        const newPartNull = { ...step, note: null, length: chopLength };
        step2 % 2 === 0 ? newClip.push(newPart) : newClip.push(newPartNull);
      }
    }

    //halve
    if (splitChop === 2) {
      let stepLengthHalved = stepLength;
      let exp = 2;

      for (let k = 0; k < splitter; k++) stepLengthHalved = stepLengthHalved / 2;
      for (let m = 0; m < splitter - 1; m++) exp = exp * 2;
      const newPartHalved = { ...step, length: stepLengthHalved };
      for (let l = 0; l < exp; l++) newClip.push(newPartHalved);
    }
  }

  return newClip;
};

function removeNotesFromChord(scribbleClip, firstChord, numOfChords, numNote) {
  if (isNaN(interval) == false) interval = Interval.fromSemitones(interval);
  if (contingency(scribbleClip, numOfChords, firstChord, false, false)) return nullCleanup(scribbleClip);
  if (firstChord < 1) return nullCleanup(scribbleClip);
  redeclareScribbleClip(scribbleClip);

  for (let i = 0; i < firstChord - 1; i++) {
    if (scribbleClip[i].note == null) firstChord++;
  }

  if (scribbleClip.length - firstChord < numOfChords) {
    var lastChord = scribbleClip.length;
  } else {
    var lastChord = firstChord - 1 + numOfChords;
  }

  for (let i = firstChord - 1; i < lastChord; i++) {
    if (scribbleClip[i].note !== null) {
      for (let n = 0; n < numNote.length; n++) {
        if (numNote[n] < scribbleClip[i].note.length + 1) {
          var newNote = 'placeholder';
          var currentChord = scribbleClip[i].note;

          for (let j = 0; j < currentChord.length; j++) {
            if (j + 1 == numNote[n]) currentChord[j] = newNote;
          }

          var newPart = { note: currentChord, length: scribbleClip[i].length, level: scribbleClip[i].level };
          scribbleClip.splice(i, 1);
          scribbleClip.insert(i, newPart);
        }
      }

      var newPart = {
        note: scribbleClip[i].note.filter((word) => word !== 'placeholder'),
        length: scribbleClip[i].length,
        level: scribbleClip[i].level,
      };
      scribbleClip.splice(i, 1);
      scribbleClip.insert(i, newPart);
    } else {
      lastChord++;
      if (lastChord > scribbleClip.length) var lastChord = scribbleClip.length;
    }
  }

  nullCleanup(scribbleClip);
  notesToArray(scribbleClip);
  return scribbleClip;
}

//It is possible to let Scribbletune make chords like notes: 'FM DM', pattern: "xxxx". That means that same chords repeat, that is their note arrays repeat. We redeclare the clip so they dont repeat
function redeclareScribbleClip(scribbleClip) {
  for (let i = 0; i < scribbleClip.length; i++) {
    var newNote = [];
    scribbleClip[i].note === null ? (newNote = null) : newNote.push(...scribbleClip[i].note);
    let newPart = { note: newNote, length: scribbleClip[i].length, level: scribbleClip[i].level };
    scribbleClip.splice(i, 1);
    scribbleClip.insert(i, newPart);
  }
  return scribbleClip;
}

//Transposes the 1st and the 3rd note octave or 2 octaves lower and higher respectively
function openChords(scribbleClip, open) {
  switch (open) {
    case 1:
      var chordPos = 0;

      for (let i = 0; i < scribbleClip.length; i++) {
        var currentChord = scribbleClip[i].note;

        if (currentChord !== null) {
          var currentChordFreqs = [];
          currentChord.forEach((element) => {
            currentChordFreqs.push(Note.freq(element));
          });
          var lowestNoteIndex = indexOfSmallest(currentChordFreqs);
          scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [lowestNoteIndex + 1], '-8P');
          currentChordFreqs[lowestNoteIndex] = 1000000;
          currentChordFreqs[indexOfSmallest(currentChordFreqs)] = 'NaN';
          currentChordFreqs[lowestNoteIndex] = 'NaN';

          for (let j = 0; j < currentChordFreqs.length; j++) {
            if (currentChordFreqs[j] !== 'NaN') {
              scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [j + 1], '8P');
            }
          }
          chordPos++;
        }
      }

      break;

    case 2:
      var chordPos = 0;

      for (let i = 0; i < scribbleClip.length; i++) {
        var currentChord = scribbleClip[i].note;

        if (currentChord !== null) {
          var currentChordFreqs = [];
          currentChord.forEach((element) => {
            currentChordFreqs.push(Note.freq(element));
          });
          var lowestNoteIndex = indexOfSmallest(currentChordFreqs);
          scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [lowestNoteIndex + 1], '-8P');
          scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [lowestNoteIndex + 1], '-8P');
          currentChordFreqs[lowestNoteIndex] = 1000000;
          currentChordFreqs[indexOfSmallest(currentChordFreqs)] = 'NaN';
          currentChordFreqs[lowestNoteIndex] = 'NaN';

          for (let j = 0; j < currentChordFreqs.length; j++) {
            if (currentChordFreqs[j] !== 'NaN') {
              scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [j + 1], '8P');
              scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [j + 1], '8P');
            }
          }
          chordPos++;
        }
      }

      break;
  }
  return scribbleClip;
}

/*
Takes the 2nd and the 4th (7th) notes and transposes them an octave higher. If there is no 4th note, it transposes only the 2nd.
*/
function Venus_Chords(scribbleClip) {
  scribbleClip = transposeNotesInChord(scribbleClip, 1, Infinity, [2, 4], '8P');
  return scribbleClip;
}

function Root_Note_Only(scribbleClip) {
  removeNotesFromChord(scribbleClip, 1, Infinity, [2, 3, 4, 5, 6, 7, 8, 9]);
  return scribbleClip;
}

function Mediant_Note_Only(scribbleClip) {
  removeNotesFromChord(scribbleClip, 1, Infinity, [1, 3, 4, 5, 6, 7, 8, 9]);
  return scribbleClip;
}

function Dominant_Note_Only(scribbleClip) {
  removeNotesFromChord(scribbleClip, 1, Infinity, [1, 2, 4, 5, 6, 7, 8, 9]);
  return scribbleClip;
}

function Seventh_Note_Only(scribbleClip) {
  removeNotesFromChord(scribbleClip, 1, Infinity, [1, 2, 3, 5, 6, 7, 8, 9]);
  return scribbleClip;
}

function Random_Note_Only(scribbleClip) {
  const chordPositions = [];

  scribbleClip.forEach((e, i) => {
    if (scribbleClip[i].note !== null) chordPositions.push(i);
  });

  for (let i = 0; i < chordPositions.length; i++) {
    let currentChord = scribbleClip[chordPositions[i]].note;
    let numNoteArr = diceMultiRollSortedASC(currentChord.length + 1, 1, currentChord.length - 1);
    removeNotesFromChord(scribbleClip, i + 1, 1, numNoteArr);
  }

  return scribbleClip;
}

function Root_and_Mediant(scribbleClip) {
  removeNotesFromChord(scribbleClip, 1, Infinity, [3, 5, 6, 7, 8, 9]);
  return scribbleClip;
}

function Power_Chords(scribbleClip) {
  removeNotesFromChord(scribbleClip, 1, Infinity, [2, 4, 5, 6, 7, 8, 9]);
  return scribbleClip;
}

//Transposes the root note an octave higher
function Inversion_1(scribbleClip) {
  scribbleClip = transposeNotesInChord(scribbleClip, 1, Infinity, [1], '8P');
  return scribbleClip;
}

//Transposes the root and the mediant note an octave higher
function Inversion_2(scribbleClip) {
  scribbleClip = transposeNotesInChord(scribbleClip, 1, Infinity, [1, 2], '8P');
  return scribbleClip;
}

//Transposes the root, mediant and dominant note an octave higher
function Inversion_3(scribbleClip) {
  scribbleClip = transposeNotesInChord(scribbleClip, 1, Infinity, [1, 2, 3], '8P');
  return scribbleClip;
}

//Removes the dominant note. Should be used with seventh chords for propper shell voicing
function Shell_Voicing(scribbleClip) {
  scribbleClip = removeNotesFromChord(scribbleClip, 1, Infinity, [3]);
  return scribbleClip;
}

//Transposes the highest note an octave lower
function Drop_1(scribbleClip) {
  let chordPos = 0;
  for (let i = 0; i < scribbleClip.length; i++) {
    if (scribbleClip[i].note !== null) {
      scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [scribbleClip[i].note.length], '-8P');
      chordPos++;
    }
  }
  return scribbleClip;
}

//Transposes the second highest note an octave lower
function Drop_2(scribbleClip) {
  let chordPos = 0;
  for (let i = 0; i < scribbleClip.length; i++) {
    if (scribbleClip[i].note !== null) {
      scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [scribbleClip[i].note.length - 1], '-8P');
      chordPos++;
    }
  }
  return scribbleClip;
}

//Transposes the third highest note an octave lower
function Drop_3(scribbleClip) {
  let chordPos = 0;
  for (let i = 0; i < scribbleClip.length; i++) {
    if (scribbleClip[i].note !== null) {
      scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [scribbleClip[i].note.length - 2], '-8P');
      chordPos++;
    }
  }
  return scribbleClip;
}

//Transposes the fourth highest note an octave lower
function Drop_4(scribbleClip) {
  let chordPos = 0;
  for (let i = 0; i < scribbleClip.length; i++) {
    if (scribbleClip[i].note !== null) {
      scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [scribbleClip[i].note.length - 3], '-8P');
      chordPos++;
    }
  }
  return scribbleClip;
}

//Looks at the root note of the first chord. If any other note is in a higher octave, it transposes it an octave lower. If any other note is in a lower octave, it transposes it an octave higher.
function Single_Octave_Chords(scribbleClip) {
  const octave = Note.octave(scribbleClip[0].note[0]);

  let chordPos = 0;
  for (let i = 0; i < scribbleClip.length; i++) {
    if (scribbleClip[i].note !== null) {
      for (let j = 0; j < scribbleClip[i].note.length; j++) {
        if (Note.octave(scribbleClip[i].note[j]) < octave) {
          scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [j + 1], '8P');
        } else if (Note.octave(scribbleClip[i].note[j]) > octave) {
          scribbleClip = transposeNotesInChord(scribbleClip, chordPos + 1, 1, [j + 1], '-8P');
        }
      }
      chordPos++;
    }
  }
  return scribbleClip;
}

//It looks at the previous chord and if there is a the same note at a different octave, it transposes the previous an octave higher or lower to the dirrection of the respective previous note.
function Same_Notes(scribbleClip) {
  const chordPositions = [];

  for (let i = 0; i < scribbleClip.length; i++) if (scribbleClip[i].note !== null) chordPositions.push(i);

  for (let i = 1; i < chordPositions.length; i++) {
    let currentChord = scribbleClip[chordPositions[i]].note;
    let previousChord = scribbleClip[chordPositions[i - 1]].note;
    let previousChordPitchClasses = [];
    previousChord.forEach((element) => {
      previousChordPitchClasses.push(Note.pitchClass(element));
    });

    for (let j = 0; j < currentChord.length; j++) {
      let currentNote = currentChord[j];

      if (previousChordPitchClasses.indexOf(Note.pitchClass(currentNote)) !== -1) {
        let sameNote = previousChord[previousChordPitchClasses.indexOf(Note.pitchClass(currentNote))];

        if (Note.octave(currentNote) < Note.octave(sameNote)) {
          scribbleClip = transposeNotesInChord(scribbleClip, i + 1, 1, [j + 1], '8P');
        } else if (Note.octave(currentNote) > Note.octave(sameNote)) {
          scribbleClip = transposeNotesInChord(scribbleClip, i + 1, 1, [j + 1], '-8P');
        }
      }
    }
  }

  return scribbleClip;
}

//It looks at the first chord of the progression and if there is any note an octave higher than the highest note of the first chord in the following chords, it transposes the note an octave lower. Visa versa with lower notes.
function First_Chord_Trim(scribbleClip) {
  const chordPositions = [];

  for (let i = 0; i < scribbleClip.length; i++) if (scribbleClip[i].note !== null) chordPositions.push(i);

  for (let i = 1; i < chordPositions.length; i++) {
    let currentChord = scribbleClip[chordPositions[i]].note;
    let firstChord = scribbleClip[chordPositions[0]].note;
    let firstChordHighestNote = firstChord[firstChord.length - 1];
    let firstChordLowestNote = firstChord[0];

    for (let j = 0; j < currentChord.length; j++) {
      let currentNote = currentChord[j];

      if (Note.freq(currentNote) < Note.freq(firstChordLowestNote)) {
        scribbleClip = transposeNotesInChord(scribbleClip, i + 1, 1, [j + 1], '8P');
      } else if (Note.freq(currentNote) > Note.freq(firstChordHighestNote)) {
        scribbleClip = transposeNotesInChord(scribbleClip, i + 1, 1, [j + 1], '-8P');
      }
    }
  }

  return scribbleClip;
}

//It looks at the last chord of the progression and if there is any note an octave higher than the highest note of the last chord in the following chords, it transposes the note an octave lower. Visa versa with lower notes.
function Last_Chord_Trim(scribbleClip) {
  const chordPositions = [];

  for (let i = 0; i < scribbleClip.length; i++) if (scribbleClip[i].note !== null) chordPositions.push(i);

  for (let i = 0; i < chordPositions.length - 1; i++) {
    let currentChord = scribbleClip[chordPositions[i]].note;
    let lastChord = scribbleClip[chordPositions[chordPositions.length - 1]].note;
    let lastChordHighestNote = lastChord[lastChord.length - 1];
    let lasttChordLowestNote = lastChord[0];

    for (let j = 0; j < currentChord.length; j++) {
      let currentNote = currentChord[j];

      if (Note.freq(currentNote) < Note.freq(lasttChordLowestNote)) {
        scribbleClip = transposeNotesInChord(scribbleClip, i + 1, 1, [j + 1], '8P');
      } else if (Note.freq(currentNote) > Note.freq(lastChordHighestNote)) {
        scribbleClip = transposeNotesInChord(scribbleClip, i + 1, 1, [j + 1], '-8P');
      }
    }
  }

  return scribbleClip;
}

//The lowest note of every chord is always lower or equal to the lowest note of the chord preceeding it.
function Descend(scribbleClip) {
  const chordPositions = [];

  for (let i = 0; i < scribbleClip.length; i++) if (scribbleClip[i].note !== null) chordPositions.push(i);

  function inner(scribbleClip, chordPositions) {
    for (let i = 1; i < chordPositions.length; i++) {
      let currentChordLength = scribbleClip[chordPositions[i]].note.length;
      let previousChord = scribbleClip[chordPositions[i - 1]].note;
      let previousChordFreqs = [];
      previousChord.forEach((element) => {
        previousChordFreqs.push(Note.freq(element));
      });
      let previousChordLowestNote = previousChord[indexOfSmallest(previousChordFreqs)];

      for (let j = currentChordLength - 1; j > -1; j--) {
        let currentChord = scribbleClip[chordPositions[i]].note;

        let currentChordFreqs = [];
        currentChord.forEach((element) => {
          currentChordFreqs.push(Note.freq(element));
        });
        let currentChordLowestNote = currentChord[indexOfSmallest(currentChordFreqs)];

        if (Note.freq(currentChordLowestNote) > Note.freq(previousChordLowestNote)) {
          scribbleClip = transposeNotesInChord(scribbleClip, i + 1, 1, [j + 1], '-8P');
        } else {
          break;
        }
      }
    }
  }
  inner(scribbleClip, chordPositions);
  inner(scribbleClip, chordPositions);

  return scribbleClip;
}

//The highest note of every chord is always lower or equal to the highest note of the chord preceeding it
function Descend_Highest(scribbleClip) {
  const chordPositions = [];

  for (let i = 0; i < scribbleClip.length; i++) if (scribbleClip[i].note !== null) chordPositions.push(i);

  function inner(scribbleClip, chordPositions) {
    for (let i = 1; i < chordPositions.length; i++) {
      let currentChordLength = scribbleClip[chordPositions[i]].note.length;
      let previousChord = scribbleClip[chordPositions[i - 1]].note;
      let previousChordFreqs = [];
      previousChord.forEach((element) => {
        previousChordFreqs.push(Note.freq(element));
      });
      let previousChordHighestNote = previousChord[indexOfHighest(previousChordFreqs)];

      for (let j = currentChordLength - 1; j > -1; j--) {
        let currentChord = scribbleClip[chordPositions[i]].note;

        let currentChordFreqs = [];
        currentChord.forEach((element) => {
          currentChordFreqs.push(Note.freq(element));
        });
        let currentChordHighestNote = currentChord[indexOfHighest(currentChordFreqs)];

        if (Note.freq(currentChordHighestNote) > Note.freq(previousChordHighestNote)) {
          scribbleClip = transposeNotesInChord(scribbleClip, i + 1, 1, [j + 1], '-8P');
        } else {
          break;
        }
      }
    }
  }
  inner(scribbleClip, chordPositions);
  inner(scribbleClip, chordPositions);

  return scribbleClip;
}

//The lowest note of every chord is always higher or equal to the lowest of the chord preceeding it
function Ascend(scribbleClip) {
  const chordPositions = [];

  for (let i = 0; i < scribbleClip.length; i++) if (scribbleClip[i].note !== null) chordPositions.push(i);
  function inner(scribbleClip, chordPositions) {
    for (let i = 1; i < chordPositions.length; i++) {
      let currentChordLength = scribbleClip[chordPositions[i]].note.length;
      let previousChord = scribbleClip[chordPositions[i - 1]].note;
      let previousChordFreqs = [];
      previousChord.forEach((element) => {
        previousChordFreqs.push(Note.freq(element));
      });
      let previousChordLowestNote = previousChord[indexOfSmallest(previousChordFreqs)];

      for (let j = 0; j < currentChordLength; j++) {
        let currentChord = scribbleClip[chordPositions[i]].note;

        let currentChordFreqs = [];
        currentChord.forEach((element) => {
          currentChordFreqs.push(Note.freq(element));
        });
        let currentChordLowestNote = currentChord[indexOfSmallest(currentChordFreqs)];

        if (Note.freq(currentChordLowestNote) < Note.freq(previousChordLowestNote)) {
          scribbleClip = transposeNotesInChord(scribbleClip, i + 1, 1, [j + 1], '8P');
        } else {
          break;
        }
      }
    }
  }
  inner(scribbleClip, chordPositions);
  inner(scribbleClip, chordPositions);

  return scribbleClip;
}

//The highest note of every chord is always higher or equal to the highest of the chord preceeding it
function Ascend_Highest(scribbleClip) {
  const chordPositions = [];

  for (let i = 0; i < scribbleClip.length; i++) if (scribbleClip[i].note !== null) chordPositions.push(i);
  function inner(scribbleClip, chordPositions) {
    for (let i = 1; i < chordPositions.length; i++) {
      let currentChordLength = scribbleClip[chordPositions[i]].note.length;
      let previousChord = scribbleClip[chordPositions[i - 1]].note;
      let previousChordFreqs = [];
      previousChord.forEach((element) => {
        previousChordFreqs.push(Note.freq(element));
      });
      let previousChordHighestNote = previousChord[indexOfHighest(previousChordFreqs)];

      for (let j = 0; j < currentChordLength; j++) {
        let currentChord = scribbleClip[chordPositions[i]].note;

        let currentChordFreqs = [];
        currentChord.forEach((element) => {
          currentChordFreqs.push(Note.freq(element));
        });
        let currentChordHighestNote = currentChord[indexOfHighest(currentChordFreqs)];

        if (Note.freq(currentChordHighestNote) < Note.freq(previousChordHighestNote)) {
          scribbleClip = transposeNotesInChord(scribbleClip, i + 1, 1, [j + 1], '8P');
        } else {
          break;
        }
      }
    }
  }
  inner(scribbleClip, chordPositions);
  inner(scribbleClip, chordPositions);

  return scribbleClip;
}

const voicingAlgos = [
  {
    name: 'none',
    algo: (scribbleClip) => scribbleClip,
    description: 'Chords are left in their basic position.',
  },
  {
    name: 'venus chords',
    algo: Venus_Chords,
    description:
      'Takes the 2nd and the 4th (7th) notes and transposes them an octave higher. If there is no 4th note, it transposes only the 2nd.',
  },
  {
    name: 'root note only',
    algo: Root_Note_Only,
    description: 'Renders only the root note of the chords.',
  },
  {
    name: 'mediant note only',
    algo: Mediant_Note_Only,
    description: 'Renders only the mediant note of the chords.',
  },
  {
    name: 'dominant note only',
    algo: Dominant_Note_Only,
    description: 'Renders only the dominant note of the chords.',
  },
  {
    name: 'seventh note only',
    algo: Seventh_Note_Only,
    description: 'Renders only the seventh note of the chords.',
  },
  {
    name: 'random note only',
    algo: Random_Note_Only,
    description: 'Renders a random note from each chord.',
  },
  {
    name: 'root and mediant',
    algo: Root_and_Mediant,
    description: 'Renders the root note and the mediant note from each chord.',
  },
  {
    name: 'power chords',
    algo: Power_Chords,
    description: 'Renders the root note and the dominant note from each chord.',
  },
  {
    name: 'inversion 1',
    algo: Inversion_1,
    description: 'Transposes the root note an octave higher.',
  },
  {
    name: 'inversion 2',
    algo: Inversion_2,
    description: 'Transposes the root and the mediant note an octave higher.',
  },
  {
    name: 'inversion 3',
    algo: Inversion_3,
    description: 'Transposes the root, mediant and dominant note an octave higher.',
  },
  {
    name: 'shell voicing',
    algo: Shell_Voicing,
    description: 'Removes the dominant note. Should be used with seventh chords for propper shell voicing.',
  },
  {
    name: 'drop 1',
    algo: Drop_1,
    description: 'Transposes the highest note an octave lower.',
  },
  {
    name: 'drop 2',
    algo: Drop_2,
    description: 'Transposes the second highest note an octave lower.',
  },
  {
    name: 'drop 3',
    algo: Drop_3,
    description: 'Transposes the third highest note an octave lower.',
  },
  {
    name: 'drop 4',
    algo: Drop_4,
    description: 'Transposes the fourth highest note an octave lower.',
  },
  {
    name: 'single octave chords',
    algo: Single_Octave_Chords,
    description:
      'Looks at the root note of the first chord. If any other note is in a higher octave, it transposes it an octave lower. If any other note is in a lower octave, it transposes it an octave higher.',
  },
  {
    name: 'same notes',
    algo: Same_Notes,
    description:
      'It looks at the previous chord and if there is a the same note at a different octave, it transposes the previous an octave higher or lower to the dirrection of the respective previous note.',
  },
  {
    name: 'first chord trim',
    algo: First_Chord_Trim,
    description:
      'It looks at the first chord of the progression and if there is any note an octave higher than the highest note of the first chord in the following chords, it transposes the note an octave lower. Visa versa with lower notes.',
  },
  {
    name: 'last chord trim',
    algo: Last_Chord_Trim,
    description:
      'It looks at the last chord of the progression and if there is any note an octave higher than the highest note of the last chord in the following chords, it transposes the note an octave lower. Visa versa with lower notes.',
  },
  {
    name: 'descend',
    algo: Descend,
    description:
      'The lowest note of every chord is always lower or equal to the lowest note of the chord preceeding it.',
  },
  {
    name: 'descend highest',
    algo: Descend_Highest,
    description:
      'The highest note of every chord is always lower or equal to the highest note of the chord preceeding it.',
  },
  {
    name: 'ascend',
    algo: Ascend,
    description: 'The lowest note of every chord is always higher or equal to the lowest of the chord preceeding it.',
  },
  {
    name: 'ascend highest',
    algo: Ascend_Highest,
    description: 'The highest note of every chord is always higher or equal to the highest of the chord preceeding it',
  },
];

/*
Generates a chord progression. Returns a scribbleclip and the chord progression as a string, so it can be manipulated again.
-RN accepts a string that denotes the root note of a key, ie 'C' of C major
-mode accepts either of the 4 possible strings: "major", "minor", "ionian", "dorian", "phrygian", "lydian", "mixolydian", "aeolian", "locrian"
-seventh denotes whether we will use seventh chords and accepts boolean.
-chords accetps an array or string that denotes chords to use and where to pick random chords, ie 'CM7 1 2 R'. 'R' denotes that this time we pick a random chord. Numbers 1-7 are a standin for the Roman numeral chord notation. Chord names are accepted in both tonal.js Scribbletune ('maj' vs 'M').
-repeatChords dictates whether randomly picked chords have a chance to be the same as chords already present in the progression.
-pattern is the Scribbletune pattern
-subdiv is the Sccribbletune subdiv
-voicing accepts string and it looks for globally scoped functions with a name same as the string to execute on the scribbleclip.
-octave accepts 0-5 and it denotes in which octave a root note of each chord should be
-bassNote accepts 1 or 0 and it denotes whether there should be a root note at octave 0 added to each chord

description to add: randomAssist, chordMap

Notes:
-For now we accept either names of chords or arabic numbers. In the future write function that will preceed this function with translation of roman to arabic. 
-When using randomAssist feature to pick a chord from a chord map, whether the previous chord is M or m is disregarded. In the future, the diferentiator needs to be added.
-Another thing with randomAssist is that when M instead of maj Maj is inputed in the chords argument. Chord input will have to be strictly controlled in the frontend. When refactoring this function, special attention will have to be paid to tha Maj M translation from tonal to Scribbletune.
*/
function makeChords(params) {
  let {
    RN,
    mode,
    seventh,
    chords,
    repeatChords,
    pattern,
    subdiv,
    randomAssist,
    chordMap,
    sizzle,
    advChords,
    open,
    voicingInt,
    octave,
    bassNote,
    splitter,
  } = params;
  seventh = humanToBool(seventh); //design choice: we convert all yes/no on/off values to boolean
  repeatChords = humanToBool(repeatChords);
  randomAssist = humanToBool(randomAssist);

  switch (seventh) {
    case false:
      var chordSet = Mode.triads(mode, RN);
      break;
    case true:
      var chordSet = Mode.seventhChords(mode, RN);
      break;
  }

  if (!isNaN(chords)) chords = chords.toString();
  if (!Array.isArray(chords)) chords = chords.split(' '); //we want to accept both strings and arrays
  chords.forEach((chord, index) => (chords[index] = chords[index].toString())); //this is here because numbers need to be strings later
  chords = romans(RN, chords); //we convert chords in roman numeral notation to absolute notation

  chordSet.forEach((chord, index) => {
    if (chordSet[index].indexOf('##') !== -1 || chordSet[index].indexOf('bb') !== -1)
      chordSet[index] = Note.simplify(chordSet[index].substring(0, 3)) + chordSet[index].substring(3, 100);
  }); //Pretty ilegible, I know. Sometimes tonal spits out C## instead of D etc, so we fix it in this line. Maybe better solution would be to adress all cases with multiple bs and #s, not just with 2.
  chordSet.forEach((chord, index) => (chordSet[index] = chordSet[index].replace(/maj/g, 'M'))); // this step is necessary, because Scribbletune does not accept maj as a denotation of major chord, instead it accepts M
  chordSet.forEach((chord, index) => (chordSet[index] = chordSet[index].replace(/Maj/g, 'M')));
  chords.forEach((chord, index) => (chords[index] = chords[index].replace(/maj/g, 'M'))); //Thanks to this we can accept either the tonal.js or Scribbletune notation (maj vs M)
  chords.forEach((chord, index) => (chords[index] = chords[index].replace(/Maj/g, 'M')));
  chordSet.forEach((chord, index) => {
    if (chordSet[index].length === 1) chordSet[index] = chordSet[index] + 'M';
  }); //Also tonal.js sometimes calls major chords without "M", ie CM is just C. Scribbletune v4+ dont accept dat!
  chordSet.forEach((chord, index) => {
    if (chordSet[index].length === 2 && chordSet[index].indexOf('#') !== -1) chordSet[index] = chordSet[index] + 'M';
  }); //just like the last one, except for black key notes
  chordSet.forEach((chord, index) => {
    if (chordSet[index].length === 2 && chordSet[index].indexOf('b') !== -1) chordSet[index] = chordSet[index] + 'M';
  });

  var chordsFinal = [];

  for (let i = 0; i < chords.length; i++) {
    //Here we convert numbers to chord names if numbers are present in the chords variable.

    if (!isNaN(chords[i])) {
      chordsFinal.push(chordSet[chords[i]]);
    } else {
      chordsFinal.push(chords[i]);
    }
  }

  const repeatchordsInputed = repeatChords; //this is here, because later the repeatChords variable needs to be reeveluated in a loop

  switch (
    randomAssist //Are we using the chordMap or not? Important branch that starts right here
  ) {
    case false: //We are not using the chordmap
      for (let i = 0; i < chords.length; i++) {
        let chordsPresent = chordSet.filter((element) => chordsFinal.includes(element)); //these 2 lines are here as a contingency for the upcoming while loop
        if (chordsPresent.length == chordSet.length) repeatChords = true;

        if (chords[i].indexOf('R') !== -1) {
          switch (repeatChords) {
            case false:
              let arr = [];
              while (arr.length < 1) {
                let chordThatWasPicked = chordSet[diceRange(7, 0)];
                if (chordsFinal.indexOf(chordThatWasPicked) === -1) arr.push(chordThatWasPicked);
              }

              chordsFinal[i] = arr[0];
              break;

            case true:
              chordsFinal[i] = chordSet[diceRange(7, 0)];
              break;
          }

          if (chords[i].length !== 1) {
            //for advanced chords with R, like Rsus4

            let currentRoot =
              chordsFinal[i].charAt(1) === 'b' || chordsFinal[i].charAt(1) === '#'
                ? (chordsFinal[i] = chordsFinal[i].charAt(0) + chordsFinal[i].charAt(1))
                : (chordsFinal[i] = chordsFinal[i].charAt(0));
            chordsFinal[i] = currentRoot + chords[i].substring(1);
          }
        }
      }
      break;

    case true: //We are using the chordmap
      for (let i = 0; i < chords.length; i++) {
        if (repeatchordsInputed === false) repeatChords = false; //a necessary reevaluation of the repeatChords variable that is here because of the chordMap

        if (i > 0) {
          //the contingency here is slightly more complex, as it needs to take into account the previous chord in regards to the chordMap
          var previousChordNumeral = absoluteToRelativeChord(RN, mode, chordsFinal[i - 1]);

          let chordsPresent = chordSet.filter((element) => chordsFinal.includes(element)); //at this part of the contingency, we look at whether all chords are already present, just like in the previous contingency

          if (chordsPresent.length == chordSet.length) repeatChords = true;

          let chordsFromPreviousChord = []; //here we check whether all chords that would follow the previous chord according to the chordMap are present.
          chordMap[previousChordNumeral].forEach((element) => chordsFromPreviousChord.push(chordSet[element - 1]));
          let chordsPresentFromPreviousChord = chordsPresent.filter((element) =>
            chordsFromPreviousChord.includes(element)
          );

          if (chordsFromPreviousChord.length == chordsPresentFromPreviousChord.length) repeatChords = true;
        } //end of the contingency

        if (chords[i].indexOf('R') !== -1) {
          switch (repeatChords) {
            case false:
              if (i === 0) {
                let arr = [];
                while (arr.length < 1) {
                  var chordsToPickFrom = chordMap[0];
                  var chordThatWasPicked = chordsToPickFrom[diceRange(chordsToPickFrom.length, 0)] - 1;
                  if (chordsFinal.indexOf(chordSet[chordThatWasPicked]) === -1) arr.push(chordSet[chordThatWasPicked]);
                }
                chordsFinal[i] = arr[0];
              } else {
                let arr = [];
                while (arr.length < 1) {
                  var chordsToPickFrom = chordMap[previousChordNumeral];
                  var chordThatWasPicked = chordsToPickFrom[diceRange(chordsToPickFrom.length, 0)] - 1;
                  if (chordsFinal.indexOf(chordSet[chordThatWasPicked]) === -1) arr.push(chordSet[chordThatWasPicked]);
                }
                chordsFinal[i] = arr[0];
              }
              break;

            case true:
              if (i === 0) {
                var chordsToPickFrom = chordMap[0];
                var chordThatWasPicked = chordsToPickFrom[diceRange(chordsToPickFrom.length, 0)] - 1;
                chordsFinal[i] = chordSet[chordThatWasPicked];
              } else {
                var chordsToPickFrom = chordMap[previousChordNumeral];
                var chordThatWasPicked = chordsToPickFrom[diceRange(chordsToPickFrom.length, 0)] - 1;
                chordsFinal[i] = chordSet[chordThatWasPicked];
              }

              break;
          }

          if (chords[i].length !== 1) {
            //for advanced chords with R, like Rsus4

            let currentRoot =
              chordsFinal[i].charAt(1) === 'b' || chordsFinal[i].charAt(1) === '#'
                ? (chordsFinal[i] = chordsFinal[i].charAt(0) + chordsFinal[i].charAt(1))
                : (chordsFinal[i] = chordsFinal[i].charAt(0));
            chordsFinal[i] = currentRoot + chords[i].substring(1);
          }
        }
      }
      break;
  }

  for (let i = 0; i < chordsFinal.length; i++) {
    //Here we have to loop through the chordsFinal array and fix any chords that Scribbletune cant read.
    if (chordsFinal[i].indexOf('mb5') !== -1) chordsFinal[i] = chordsFinal[i].replace(/mb5/g, 'dim');
    if (chordsFinal[i].indexOf('m7b5') !== -1) chordsFinal[i] = chordsFinal[i].replace(/m7b5/g, 'dim7');

    if (
      (chordsFinal[i].length < 4 && chordsFinal[i].indexOf('7') == 1) ||
      (chordsFinal[i].length < 4 && chordsFinal[i].indexOf('#7') == 1) ||
      (chordsFinal[i].length < 4 && chordsFinal[i].indexOf('b7') == 1)
    )
      chordsFinal[i] = chordsFinal[i] + 'th'; //Again with the th at the end of G7. the < 4 condition is there so we are able to accept crazy chords like D#7#11b13
    if (chordsFinal[i].indexOf('thth') !== -1) chordsFinal[i] = chordsFinal[i].replace(/thth/g, 'th');
  }

  if (advChords !== 'none') {
    //if we want to, we transform all the chords into any accepted crazy chord in the following 2 loops
    chordsFinal.forEach((chord, index) => {
      chordsFinal[index].charAt(1) === 'b' || chordsFinal[index].charAt(1) === '#'
        ? (chordsFinal[index] = chordsFinal[index].charAt(0) + chordsFinal[index].charAt(1))
        : (chordsFinal[index] = chordsFinal[index].charAt(0));
    });
    chordsFinal.forEach((chord, index) => {
      chordsFinal[index] = chordsFinal[index] + advChords;
    });
  }
  chordsFinal = chordsFinal.join(' ');

  var scribbleClip = scribble.clip({
    notes: chordsFinal,
    pattern,
    subdiv,
    sizzle,
  });

  const rootNotes = []; //In these 3 steps we extract root notes of chords before they go to voicingCallback
  scribbleClip.forEach((element) => {
    element.note === null ? rootNotes.push('n') : rootNotes.push(element.note[0]);
  });
  rootNotes.forEach((chord, index) => {
    rootNotes[index].charAt(1) === 'b' || rootNotes[index].charAt(1) === '#'
      ? (rootNotes[index] = rootNotes[index].charAt(0) + rootNotes[index].charAt(1))
      : (rootNotes[index] = rootNotes[index].charAt(0));
  });

  // const voicingCallback = global[voicing]; //this is a way through which a function can be passed to another function as a string and yet it will still act as a callback
  // scribbleClip = voicingCallback(scribbleClip);
  scribbleClip = voicingAlgos[voicingInt].algo(scribbleClip);

  chordsToOctave(scribbleClip, octave);

  if (open) openChords(scribbleClip, open);

  if (bassNote) augmentChordsWithBassNote2(scribbleClip, rootNotes, bassNote);

  if (splitter) var scribbleClip = chopSplitHalve(params, scribbleClip);

  return [scribbleClip, chordsFinal];
}

module.exports = {
  makeChords,
  translateChordMap,
  voicingAlgos,
};

// const asd = makeChords({
//   chordMap: [
//     0, 0, 1, 1, 0, 1, 2, 0, 1, 3, 0, 1, 4, 0, 1, 5, 0, 1, 6, 0, 1, 0, 1, 0, 1, 1, 1, 2, 1, 1, 3, 1, 1, 4, 1, 1, 5, 1, 1,
//     6, 1, 1, 0, 2, 0, 1, 2, 0, 2, 2, 1, 3, 2, 1, 4, 2, 1, 5, 2, 0, 6, 2, 0, 0, 3, 1, 1, 3, 1, 2, 3, 0, 3, 3, 1, 4, 3, 0,
//     5, 3, 1, 6, 3, 0, 0, 4, 1, 1, 4, 0, 2, 4, 1, 3, 4, 0, 4, 4, 1, 5, 4, 1, 6, 4, 0, 0, 5, 1, 1, 5, 0, 2, 5, 0, 3, 5, 1,
//     4, 5, 0, 5, 5, 1, 6, 5, 0, 0, 6, 1, 1, 6, 1, 2, 6, 0, 3, 6, 1, 4, 6, 1, 5, 6, 0, 6, 6, 0, 0, 7, 1, 1, 7, 0, 2, 7, 0,
//     3, 7, 1, 4, 7, 0, 5, 7, 1, 6, 7, 0,
//   ],
//   bassNote: 0,
//   open: 0,
//   randomAssist: 1,
//   repeatChords: 1,
//   seventh: 0,
//   splitChop: 0,
//   RN: 'Fb',
//   mode: 'Major',
//   octave: 0,
//   sizzle: 'sin',
//   advChords: 'none',
//   voicing: 'none',
//   subdiv: '4n',
//   splitter: 0,
//   chordPatterns: ['R', 'R', 'R', 'R'],
//   patterns: 'xxxx',
//   pattern: 'xxxx',
//   chords: ['R', 'R', 'R', 'R'],
// });
